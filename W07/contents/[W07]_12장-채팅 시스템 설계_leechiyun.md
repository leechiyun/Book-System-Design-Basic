# 12장. 채팅 시스템 설계

## 1단계. 문제 이해 및 설계 범위 확정

- **요구 사항**
    - 1:1채팅, 그룹 채팅 가능
    - 웹 + 모바일
    - DAU(일별 능동 사용자 수) 5천만 명
    - 그룹 인원 제한 : 100명
    - 접속 상태 표시 지원
    - 텍스트 메시지만 주고받는다.
    - 메시지 길이 제한: 100000자
    - 종단간 암호화 기능
        - 주고받는 메시지 및 통화 내용이 나의 기기를 떠나는 순간부터 수신자의 기기에 도달할 때까지 보호된다는 것을 의미

- **정리**
    - 응답지연이 낮은 일대일 채팅 기능
    - 최대 100명까지 참여 가능한 그룹 채팅 기능
    - 사용자 접속상태 표시 기능
    - 다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원
    - 푸시 알림

## 2단계. 개략적 설계안 제시 및 동의 구하기

- 클라이언트와 서버의 통신 방법
    - 클라이언트는 서로 직접 통신 X

- 기본 기능
    - 클라이언트들로부터 메시지 수신
    - 메시지 수신자 결정 및 전달
    - 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled.png)

- 송신 클라이언트 → 수신 클라이언트
    - HTTP 프로토콜 사용
        - TCP 접속 과정에서 발생하는 핸드셰이크 횟수 줄임

- **폴링**
    - 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는 방법
    - 폴링이 자주 발생하면 비용이 오른다
    - 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비됨
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%201.png)
        

- **롱 폴링**
    - 폴링 기법에서 타임아웃을 설정
    - 문제점
        - 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
        - HTTP 서버 = 무상태성
        - 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우
            - 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
        - 서버에서는 클라이언트가 연결을 종료했는지 모른다. (타임아웃 기간까지 유지할 뿐)
        - 여전히 비효율적. 타임아웃이 있더라고 주기적으로 서버에 다시 접속할 것

- **웹 소켓**
    - 서버가 클라이언트에게 비동기(async) 메시지를 보낼 때 사용
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%202.png)
        

- 연결이 맺어지면 영구적이며, 양방향이다.
- 처음에는 HTTP 연결이지만, 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드.
- 서버는 클라이언트에게 비동기적으로 메시지 전송
- 방화벽이 있는 환경에서도 동작
    - 80, 443처럼 HTTP, HTTPS 프로토콜의 기본 포트를 사용하기 때문
- 서버에 연결도 쉽고, 직관적. 하지만, 영구적이기에 서버에서 효율적인 연결 관리 필수.

### 개약적 설계안

- 채팅 시스템
    - 무상태 서비스 / 상태유지 서비스 / 제3자 서비스 연동
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%203.png)
        

- **무상태 서비스**
    - 전통적인 요청/응답 서비스 (로그인, 회원가입, 프로필 표시, …)
    - 로드밸런서로 각 서비스로 정확히 전달.
    - 서비스 탐색 서비스
        - 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할

- **상태 유지 서비스**
    - 채팅 서비스
        - 각 클라이언트는 채팅 서버와 독립적인 연결

- **제3자 서비스 연동**
    - 채팅 앱에서 가장 중요한 제3자 서비스는 푸시 알림
    - 새 메시지를 받으면, 사용중이 아니더라도 푸시 알림을 제공한다.

- **규모 확장성**
    - 기본적으로 사용자가 적은 경우 서버 한대만으로 충분
    - 단, 서버 한대의 경우 SPOF(단일 실패 지점) 문제 방생
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%204.png)
        
    - 채팅 서버 : 클라이언트 사이에 메시지를 중계하는 역할
    - 접속상태 서버: 사용자 접속 여부를 관리
    - API 서버: 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 처리
    - 알림 서버: 푸시 알림 제공
    - 키-값 저장소: 채팅 이력 보관.

- **저장소**
    - RDBMS vs NoSQL
    - 채팅 시스템이 다루는 데이터
        - 사용자 프로필, 설정, 친구 목록 → 일반 데이터
        - 채팅 이력 → 채팅 시스템의 고유 데이터

- 채팅 이력 데이터는 엄청 크다.
- 대부분의 사용자는 오래된 메시지를 확인하지 않는다.
- 특정 데이터를 검색을 통해 점프할 수 있다.

- 키-값 저장소
    - 수평적 규모확장이 쉽다.
    - 데이터 접근 지연시간이 낮다.
    - 인덱스가 커지면 random access 비용이 늘어난다.

- **데이터 모델**
    - 1:1 채팅을 위한 메시지 테이블
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%205.png)
        
        - 기본 키: message_id
    
    - 그룹 채팅을 위한 메시지 테이블
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%206.png)
        
        - 복합 키: (channel_id, message_id)
        
    - **메시지 ID**
        - unique
        - 정렬 가능, 시간 순서 일치
        - NoSQL → 지역적 순서 번호 생성기

## 3단계. 상세 설계

- 서비스 탐색, 메시지 전달 흐름, 사용자 접속 상태 표시, …

- **서비스 탐색**
    - 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
    - **기준**
        - 클라이언트 위치
        - 서버 용량
    - 아파티 주키퍼
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%207.png)
        
        1. 사용자 A가 시스템에 로그인
        2. 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보냄
        3. API 서버가 사용자 인증을 처리하고 나면, 서비스 탐색 기능이 동작하여 해당 사용자를 서비스할 최적의 채팅서버를 찾음
        4. 사용자 A는 최적의 채팅 서버 2와 웹소켓 연결

- **메시지 흐름**
    - 1:1 채팅 메시지 처리 흐름
        
        ![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%208.png)
        
        1. 사용자 A가 채팅 서버 1로 메시지 전송
        2. 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
        3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
        4. 메시지가 키-값 저장소에 보관됨
        5. 접속 중 / 미접속 중
            1. 사용자 B가 접속 중인 경우, 메시지는 사용자 B가 접속 중인 채팅 서버
            2. 사용자 B가 접속 중이 아니라면, 알림 메시지를 푸시 알림 서버
        6. 채팅 서버 2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

- 단체 메시지의 경우 **메시지 동기화 큐**를 사용

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20ca868a4a26ed4192a599b305f9100c66/Untitled%209.png)

## !Tip

- **라운드 로빈 알고리즘**
    - 프로세스 스케줄링, 네트워크 부하 분산 등 다양한 분야에서 사용되는 간단하면서도 효과적인 알고리즘

- **기본 개념**
    - 모든 작업(또는 프로세스)에 동일한 우선순위를 부여합니다.
    - 순환 순서로 각 작업에 일정 시간 또는 자원을 할당합니다.
- **작동 방식**
    - 작업들을 원형 큐(circular queue)로 배열합니다.
    - 각 작업에 순서대로 일정량의 시간(타임 퀀텀)을 할당합니다.
    - 할당된 시간이 끝나면 다음 작업으로 넘어갑니다.
    - 이 과정을 모든 작업이 완료될 때까지 반복합니다.
- **장점**
    - 공정성: 모든 작업에 동등한 기회를 제공합니다.
    - 기아 상태 방지: 어떤 작업도 무한정 대기하지 않습니다.
    - 구현이 간단합니다.
- **단점**
    - 작업의 중요도나 긴급성을 고려하지 않습니다.
    - 짧은 작업과 긴 작업에 대해 동일한 대기 시간을 적용합니다.
- **응용 분야**
    - 운영 체제의 프로세스 스케줄링
    - 네트워크 트래픽 관리
    - 웹 서버의 요청 처리
- **변형**
    - 가중치 라운드 로빈: 작업에 가중치를 부여하여 중요도를 반영합니다.
    - 동적 라운드 로빈: 시스템 상태에 따라 타임 퀀텀을 조절합니다.